/*
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */function testScanTextNoTags(){var e="<h2>hi</h2>",t=Hogan.scan(e);is(t.length,1,"One token");is(t[0]+"",e,"text is equal to first token")}function testScanOneTag(){var e="{{hmm}}",t=Hogan.scan(e);is(t.length,1,"One token");is(t[0].n,"hmm","First token content is variable name.")}function testScanMultipleTags(){var e="asdf{{hmm}}asdf2{{hmm2}}asdf3",t=Hogan.scan(e);is(t.length,5,"3 text tokens, 2 tag tokens.");is(t[0]+"","asdf","first token is text");is(t[1].n,"hmm","second token is tag");is(t[1].tag,"_v","second token is a variable");is(t[2]+"","asdf2","third token is text");is(t[3].n,"hmm2","fourth token is tag");is(t[3].tag,"_v","fourth token is a variable");is(t[4]+"","asdf3","Fifth token is text")}function testScanSectionOpen(){var e="{{#hmm}}",t=Hogan.scan(e);is(t.length,1,"One token");is(t[0].n,"hmm","First token content is variable name.");is(t[0].tag,"#","First token is a section.")}function testScanSectionClose(){var e="{{/hmm}}",t=Hogan.scan(e);is(t.length,1,"One token");is(t[0].n,"hmm","First token content is variable name.");is(t[0].tag,"/","First token is a section.")}function testScanSection(){var e="{{#hmm}}{{/hmm}}",t=Hogan.scan(e);is(t.length,2,"One token");is(t[0].n,"hmm","First token content is variable name.");is(t[0].tag,"#","First token is a section.");is(t[1].n,"hmm","Second token content is variable name.");is(t[1].tag,"/","Second token is a section.")}function testScanSectionInContent(){var e="abc{{#hmm}}def{{/hmm}}ghi",t=Hogan.scan(e);is(t.length,5,"3 text tokens, 2 tag tokens.");is(t[0]+"","abc","first token is text");is(t[1].n,"hmm","second token is tag");is(t[1].tag,"#","second token is a variable");is(t[2]+"","def","third token is text");is(t[3].n,"hmm","fourth token is tag");is(t[3].tag,"/","fourth token is a variable");is(t[4]+"","ghi","Fifth token is text")}function testScanNegativeSection(){var e="{{^hmm}}{{/hmm}}",t=Hogan.scan(e);is(t.length,2,"One token");is(t[0].n,"hmm","First token content is variable name.");is(t[0].tag,"^","First token is a negative section.");is(t[1].n,"hmm","First token content is variable name.");is(t[1].tag,"/","Second token is a section.")}function testScanPartial(){var e="{{>hmm}}",t=Hogan.scan(e);is(t.length,1,"One token");is(t[0].n,"hmm","First token content is variable name.");is(t[0].tag,">","First token is a partial.")}function testScanBackwardPartial(){var e="{{<hmm}}",t=Hogan.scan(e);is(t.length,1,"One token");is(t[0].n,"hmm","First token content is variable name.");is(t[0].tag,"<","First token is a backward partial.")}function testScanAmpersandNoEscapeTag(){var e="{{&hmm}}",t=Hogan.scan(e);is(t.length,1,"One token");is(t[0].n,"hmm","First token content is variable name.");is(t[0].tag,"&","First token is an ampersand no-escape.")}function testScanTripleStache(){var e="{{{hmm}}}",t=Hogan.scan(e);is(t.length,1,"One token");is(t[0].n,"hmm","First token content is variable name.");is(t[0].tag,"{","First token is a triple-stache.")}function testScanSectionWithTripleStacheInside(){var e="a{{#yo}}b{{{hmm}}}c{{/yo}}d",t=Hogan.scan(e);is(t.length,7,"One token");is(t[0]+"","a","First token content is correct text.");is(t[1].n,"yo","Second token content is correct text.");is(t[1].tag,"#","Second token is a section.");is(t[2]+"","b","Third token content is correct text.");is(t[3].n,"hmm","Fourth token content is correct text.");is(t[3].tag,"{","Fourth token is a triple stache.");is(t[4]+"","c","Fifth token content is correct text.");is(t[5].n,"yo","Sixth token content is correct text.");is(t[5].tag,"/","Sixth token is a close.");is(t[6]+"","d","Seventh token content is correct text.")}function testScanSetDelimiter(){var e="a{{=<% %>=}}b",t=Hogan.scan(e);is(t.length,2,"change delimiter doesn't appear as token.");is(t[0]+"","a","text before change delimiter is processed.");is(t[1]+"","b","text after change delimiter is processed.")}function testScanResetDelimiter(){var e="a{{=<% %>=}}b<%hmm%>c<%={{ }}=%>d{{hmm}}",t=Hogan.scan(e);is(t.length,6,"8 tokens, delimiter changes don't count.");is(t[0]+"","a","first token is correct.");is(t[1]+"","b","third token is correct.");is(t[2].tag,"_v","third token is correct tag.");is(t[2].n,"hmm","third token is correct name.");is(t[3]+"","c","fifth token is correct.");is(t[4]+"","d","seventh token is correct.");is(t[5].tag,"_v","eighth token is correct tag.");is(t[5].n,"hmm","eighth token is correct name.")}function testSingleCharDelimiter(){var e="({{foo}} {{=[ ]=}}[text])",t=Hogan.scan(e),n=Hogan.compile(e);s=n.render({foo:"bar",text:"It worked!"});is(s,"(bar It worked!)","Hogan substitution worked after custom delimiters.")}function testSetDelimiterWithWhitespace(){var e="{{= | | =}}|foo|",t=Hogan.compile(e);s=t.render({foo:"bar"});is(s,"bar","custom delimiters with whitespace works.")}function testParseBasic(){var e="test",t=Hogan.parse(Hogan.scan(e));is(t.length,1,"one parse node");is(t[0]+"","test","text is correct")}function testParseVariables(){var e="test{{foo}}test!{{bar}}test!!{{baz}}test!!!",t=Hogan.parse(Hogan.scan(e));is(t.length,7,"one parse node");is(t[0]+"","test","first text is correct");is(t[2]+"","test!","second text is correct");is(t[4]+"","test!!","third text is correct");is(t[6]+"","test!!!","last text is correct");is(t[1].n,"foo","first var is correct");is(t[3].n,"bar","second var is correct");is(t[5].n,"baz","third var is correct")}function testParseSection(){var e="a{{#foo}}b{{/foo}}c",t=Hogan.parse(Hogan.scan(e));is(t.length,3,"three nodes at base");is(t[0]+"","a","correct text in first node");is(t[1].hasOwnProperty("nodes"),!0,"second node is a section");is(t[1].tag,"#","second node is a section");is(t[1].n,"foo","correct name for section");is(t[1].nodes[0]+"","b","correct text in section");is(t[2]+"","c","correct text in last node")}function testParseIndexes(){var e="abc{{#foo}}asdf{{bar}}asdf{{/foo}}def",t=Hogan.parse(Hogan.scan(e));is(e.substring(t[1].i,t[1].end),"asdf{{bar}}asdf","section text indexes are correct")}function testParseNegativeSection(){var e="a{{^foo}}b{{/foo}}c",t=Hogan.parse(Hogan.scan(e));is(t.length,3,"three nodes at base");is(t[0]+"","a","correct text in first node");is(t[1].hasOwnProperty("nodes"),!0,"second node is a section");is(t[1].tag,"^","second node is a negative section");is(t[1].n,"foo","correct name for section");is(t[1].nodes[0]+"","b","correct text in section");is(t[2]+"","c","correct text in last node")}function testParseNestedSections(){var e="{{#bar}}{{#foo}}c{{/foo}}{{/bar}}",t=Hogan.parse(Hogan.scan(e));is(t.length,1,"one node at base");is(t[0].tag,"#","open section is first node");is(t[0].n,"bar","first section name is 'bar'");is(t[0].nodes.length,1,"first section contains one node.");is(t[0].nodes[0].n,"foo","correct name for nested section");is(t[0].nodes[0].nodes[0]+"","c","correct text in nested section")}function testMissingClosingTag(){var e="a{{#foo}}bc",t="";try{var n=Hogan.parse(Hogan.scan(e))}catch(r){t=r.message}is(t,"missing closing tag: foo","Error is generated")}function testBadNesting(){var e="a{{#foo}}{{#bar}}b{{/foo}}{{/bar}}c",t="";try{var n=Hogan.parse(Hogan.scan(e))}catch(r){t=r.message}is(t,"Nesting error: bar vs. foo","Error is generated")}function testBasicOutput(){var e="test",t=Hogan.compile(e);is(t.render(),e,"template renders one text node")}function testBasicOutputAsString(){var e="test",t=Hogan.compile(e,!0);is(t,"function(context, partials){this.buffer.push('test');};","template renders correct text function.")}function testOneVariable(){var e="test {{foo}} test",t=Hogan.compile(e),n=t.render({foo:"bar"});is(n,"test bar test","basic variable substitution works.")}function testOneVariableAsString(){var e="test {{foo}} test",t=Hogan.compile(e,!0);is(t,"function(context, partials){this.buffer.push('test ');\nthis.buffer.push(this.find('foo', context));\nthis.buffer.push(' test');};","Function text is correct with variable substitution.")}function testRenderWithWhitespace(){var e="{{ string }}",t=Hogan.compile(e);is(t.render({string:"---"}),"---","tags with whitespace render correctly.")}function testRenderWithWhitespaceAroundTripleStache(){var e="  {{{string}}}\n",t=Hogan.compile(e);is(t.render({string:"---"}),"  ---\n","triple stache surrounded by whitespace render correctly.")}function testRenderWithWhitespaceAroundAmpersand(){var e="  {{& string }}\n",t=Hogan.compile(e);is(t.render({string:"---"}),"  ---\n","ampersand surrounded by whitespace render correctly.")}function testMultipleVariables(){var e="test {{foo}} test {{bar}} test {{baz}} test {{foo}} test",t=Hogan.compile(e),n=t.render({foo:"42",bar:"43",baz:"44"});is(n,"test 42 test 43 test 44 test 42 test","all variables render correctly.")}function testNumberValues(){var e="integer: {{foo}} float: {{bar}} negative: {{baz}}",t=Hogan.compile(e),n=t.render({foo:42,bar:42.42,baz:-42});is(n,"integer: 42 float: 42.42 negative: -42","numbers render correctly")}function testObjectRender(){var e="object: {{foo}}",t=Hogan.compile(e),n=t.render({foo:{}});is(n,"object: [object Object]","objects render default toString.")}function testObjectToStringRender(){var e="object: {{foo}}",t=Hogan.compile(e),n=t.render({foo:{toString:function(){return"yo!"}}});is(n,"object: yo!","objects render supplied toString.")}function testArrayRender(){var e="array: {{foo}}",t=Hogan.compile(e),n=t.render({foo:["a","b","c"]});is(n,"array: a,b,c","arrays render default toString.")}function testEscaping(){var e="{{foo}}",t=Hogan.compile(e),n=t.render(),n=t.render({foo:"< > <div> ' \" &"});is(n,"&lt; &gt; &lt;div&gt; &#39; &quot; &amp;","input correctly escaped.");var r={"'":"&#39;",'"':"&quot;","<":"&lt;",">":"&gt;","&":"&amp;"};for(var i in r){var n=t.render({foo:i+" just me"});is(n,r[i]+" just me","input correctly escaped.")}}function testMustacheInjection(){var e="{{foo}}",t=Hogan.compile(e);s=t.render({foo:"{{{<42}}}"});is(s,"{{{&lt;42}}}","Can't inject mustache")}function testTripleStache(){var e="{{{foo}}}",t=Hogan.compile(e),n=t.render({foo:"< > <div> ' \" &"});is(n,"< > <div> ' \" &","input correctly not-escaped.")}function testAmpNoEscaping(){var e="{{&foo}}",t=Hogan.compile(e),n=t.render({foo:"< > <div> ' \" &"});is(n,"< > <div> ' \" &","input correctly not-escaped.")}function testPartial(){var e="this is text from the partial--the magic number {{foo}} is from a variable",t=Hogan.compile(e),n="This template contains a partial ({{>testPartial}}).",r=Hogan.compile(n),i=r.render({foo:42},{testPartial:t});is(i,"This template contains a partial (this is text from the partial--the magic number 42 is from a variable).","partials work")}function testNestedPartials(){var e="this is text from the partial--the magic number {{foo}} is from a variable",t=Hogan.compile(e),n="This template contains a partial ({{>testPartial}}).",r=Hogan.compile(n),i="This template contains a partial that contains a partial [{{>testPartial2}}].",s=Hogan.compile(i),o=s.render({foo:42},{testPartial:t,testPartial2:r});is(o,"This template contains a partial that contains a partial [This template contains a partial (this is text from the partial--the magic number 42 is from a variable).].","nested partials work")}function testNegativeSection(){var e="This template {{^foo}}BOO {{/foo}}contains an inverted section.",t=Hogan.compile(e),n=t.render();is(n,"This template BOO contains an inverted section.","inverted sections with no context work");n=t.render({foo:[]});is(n,"This template BOO contains an inverted section.","inverted sections with empty list context work");n=t.render({foo:!1});is(n,"This template BOO contains an inverted section.","inverted sections with false context work");n=t.render({foo:""});is(n,"This template contains an inverted section.","inverted sections with empty string context work");n=t.render({foo:!0});is(n,"This template contains an inverted section.","inverted sections with true context work");n=t.render({foo:function(){return!1}});is(n,"This template BOO contains an inverted section.","inverted sections with false returning method in context work")}function testSectionElision(){var e="This template {{#foo}}BOO {{/foo}}contains a section.",t=Hogan.compile(e),n=t.render();is(n,"This template contains a section.","sections with no context work");n=t.render({foo:[]});is(n,"This template contains a section.","sections with empty list context work");n=t.render({foo:!1});is(n,"This template contains a section.","sections with false context work")}function testSectionObjectContext(){var e="This template {{#foo}}{{bar}} {{/foo}}contains a section.",t=Hogan.compile(e),n=t.render({foo:{bar:42}});is(n,"This template 42 contains a section.","sections with object context work")}function testSectionArrayContext(){var e="This template {{#foo}}{{bar}} {{/foo}}contains a section.",t=Hogan.compile(e),n=t.render({foo:[{bar:42},{bar:43},{bar:44}]});is(n,"This template 42 43 44 contains a section.","sections with object ctx and array values work")}function testFalsyVariableNoRender(){var e="I ({{cannot}}) be seen!",t=Hogan.compile(e),n=t.render();is(n,"I () be seen!","missing value doesn't render.")}function testSectionExtensions(){var e="Test {{_//|__foo}}bar{{/foo}}",t={sectionTags:[{o:"_//|__foo",c:"foo"}]},n=Hogan.parse(Hogan.scan(e),t);is(n[1].tag,"#","_//|__foo node transformed to section");is(n[1].n,"_//|__foo","_//|__foo node transformed to section");var r=Hogan.compile(e,t),i=r.render({"_//|__foo":!0});is(i,"Test bar","Custom sections work")}function testMisnestedSectionExtensions(){var e="Test {{__foo}}bar{{/bar}}",t={sectionTags:[{o:"__foo",c:"foo"},{o:"__bar",c:"bar"}]},n="";try{var r=Hogan.parse(Hogan.scan(e),t)}catch(i){n=i.message}is(n,"Nesting error: __foo vs. bar","Error is generated")}function testNestedSection(){var e="{{#foo}}{{#bar}}{{baz}}{{/bar}}{{/foo}}",t=Hogan.compile(e),n=t.render({foo:42,bar:42,baz:42});is(n,"42","can reach up context stack")}function testDottedNames(){var e='"{{person.name}}" == "{{#person}}{{name}}{{/person}}"',t=Hogan.compile(e),n=t.render({person:{name:"Joe"}});is(n,'"Joe" == "Joe"',"dotted names work")}function testImplicitIterator(){var e="{{#stuff}} {{.}} {{/stuff}}",t=Hogan.compile(e),n=t.render({stuff:[42,43,44]});is(n," 42  43  44 ","implicit iterators work")}function testPartialsAndDelimiters(){var e="{{>include}}*\n{{= | | =}}\n*|>include|",t=" .{{value}}. ",n=Hogan.compile(t),r=Hogan.compile(e),i=r.render({value:"yes"},{include:n});is(i," .yes. *\n* .yes. ","partials work around delimiters")}function testStringPartials(){var e="foo{{>mypartial}}baz",t=" bar ",n=Hogan.compile(e),r=n.render({},{mypartial:t});is(r,"foo bar baz","string partial works.")}function testMissingPartials(){var e="foo{{>mypartial}} bar",t=Hogan.compile(e),n=t.render({});is(n,"foo bar","missing partial works.")}function testIndentedStandaloneComment(){var e="Begin.\n {{! Indented Comment Block! }}\nEnd.",t=Hogan.compile(e),n=t.render();is(n,"Begin.\nEnd.","Standalone comment blocks are removed.")}function testNewLineBetweenDelimiterChanges(){var e={section:!0,data:"I got interpolated."},t="\n{{#section}}\n {{data}}\n |data|\n{{/section}}x\n\n{{= | | =}}\n|#section|\n {{data}}\n |data|\n|/section|",n=Hogan.compile(t),r=n.render(e);is(r,"\n I got interpolated.\n |data|\nx\n\n {{data}}\n I got interpolated.\n","render correct")}function testMustacheJSApostrophe(){var e="{{apos}}{{control}}",t=Hogan.compile(e),n=t.render({apos:"'",control:"X"});is(n,"&#39;X","Apostrophe is escaped.")}function testMustacheJSArrayOfImplicitPartials(){var e="Here is some stuff!\n{{#numbers}}\n{{>partial}}\n{{/numbers}}\n",t="{{.}}\n",n=Hogan.compile(e),r=n.render({numbers:[1,2,3,4]},{partial:t});is(r,"Here is some stuff!\n1\n2\n3\n4\n","Partials with implicit iterators work.")}function testMustacheJSArrayOfPartials(){var e="Here is some stuff!\n{{#numbers}}\n{{>partial}}\n{{/numbers}}\n",t="{{i}}\n",n=Hogan.compile(e),r=n.render({numbers:[{i:1},{i:2},{i:3},{i:4}]},{partial:t});is(r,"Here is some stuff!\n1\n2\n3\n4\n","Partials with arrays work.")}function testMustacheJSArrayOfStrings(){var e="{{#strings}}{{.}} {{/strings}}",t=Hogan.compile(e),n=t.render({strings:["foo","bar","baz"]});is(n,"foo bar baz ","array of strings works with implicit iterators.")}function testMustacheJSUndefinedString(){var e="foo{{bar}}baz",t=Hogan.compile(e),n=t.render({bar:undefined});is(n,"foobaz","undefined value does not render.")}function testMustacheJSTripleStacheAltDelimiter(){var e="{{=<% %>=}}<% foo %> {{foo}} <%{bar}%> {{{bar}}}",t=Hogan.compile(e),n=t.render({foo:"yeah",bar:"hmm"});is(n,"yeah {{foo}} hmm {{{bar}}}","triple stache inside alternate delimiter works.")}function testShootOutString(){var e="Hello World!",t="Hello World!",n=Hogan.compile(e),r=n.render({});is(r,t,"Shootout String compiled correctly")}function testShootOutReplace(){var e="Hello {{name}}! You have {{count}} new messages.",t="Hello Mick! You have 30 new messages.",n=Hogan.compile(e),r=n.render({name:"Mick",count:30});is(r,t,"Shootout Replace compiled correctly")}function testShootOutArray(){var e="{{#names}}{{name}}{{/names}}",t="MoeLarryCurlyShemp",n=Hogan.compile(e),r=n.render({names:[{name:"Moe"},{name:"Larry"},{name:"Curly"},{name:"Shemp"}]});is(r,t,"Shootout Array compiled correctly")}function testShootOutObject(){var e="{{#person}}{{name}}{{age}}{{/person}}",t="Larry45",n=Hogan.compile(e),r=n.render({person:{name:"Larry",age:45}});is(r,t,"Shootout Object compiled correctly")}function testShootOutPartial(){var e="{{#peeps}}{{>replace}}{{/peeps}}",t=Hogan.compile(e),n=Hogan.compile(" Hello {{name}}! You have {{count}} new messages."),r=t.render({peeps:[{name:"Moe",count:15},{name:"Larry",count:5},{name:"Curly",count:2}]},{replace:n}),i=" Hello Moe! You have 15 new messages. Hello Larry! You have 5 new messages. Hello Curly! You have 2 new messages.";is(r,i,"Shootout Partial compiled correctly")}function testShootOutRecurse(){var e="{{name}}{{#kids}}{{>recursion}}{{/kids}}",t=Hogan.compile(e),n=Hogan.compile("{{name}}{{#kids}}{{>recursion}}{{/kids}}"),r=t.render({name:"1",kids:[{name:"1.1",kids:[{name:"1.1.1",kids:[]}]}]},{recursion:n}),i="11.11.1.1";is(r,i,"Shootout Recurse compiled correctly")}function testShootOutFilter(){var e="{{#filter}}foo {{bar}}{{/filter}}",t=Hogan.compile(e),n=t.render({filter:function(){return function(e,t){return t(e).toUpperCase()}},bar:"bar"}),r="FOO BAR";is(n,r,"Shootout Filter compiled correctly")}function testShootOutComplex(){var e='<h1>{{header}}</h1>{{#hasItems}}<ul>{{#items}}{{#current}}<li><strong>{{name}}</strong></li>{{/current}}{{^current}}<li><a href="{{url}}">{{name}}</a></li>{{/current}}{{/items}}</ul>{{/hasItems}}{{^hasItems}}<p>The list is empty.</p>{{/hasItems}}',t='<h1>Colors</h1><ul><li><strong>red</strong></li><li><a href="#Green">green</a></li><li><a href="#Blue">blue</a></li></ul>',n=Hogan.compile(e),r=n.render({header:function(){return"Colors"},items:[{name:"red",current:!0,url:"#Red"},{name:"green",current:!1,url:"#Green"},{name:"blue",current:!1,url:"#Blue"}],hasItems:function(){return this.items.length!==0},empty:function(){return this.items.length===0}});is(r,t,"Shootout Complex compiled correctly")}function testRenderOutput(){if(doc)return;var e=require("fs"),t="test/templates",n="test/html";e.readdirSync(t).forEach(function(r){var i=e.readFileSync([t,r].join("/"),"utf-8"),s=Hogan.compile(i),o=s.render({}),u=e.readFileSync([n,r].join("/").replace(/mustache$/,"html")).toString();is(o===u,!0,r+" should correctly render html")})}function testDefaultRenderImpl(){var e=new Hogan.Template;is(e.render()==="",!0,"default renderImpl returns an array.")}function appendText(e,t){var n=document.createTextNode(t);e.appendChild(n);e.appendChild(document.createElement("br"))}function is(e,t,n){if(e===t){output("OK:   "+n);++passed}else{output("FAIL: "+n);output("Expected |"+t+"|");output("     Got |"+e+"|");++failed}}function complete(){output("\nTests Complete");output("--------------");output("Passed: "+passed);output("Failed: "+failed);output("\n")}function runTests(){output("Tests Starting");output("--------------");testScanTextNoTags();testScanOneTag();testScanMultipleTags();testScanSectionOpen();testScanSectionClose();testScanSection();testScanSectionInContent();testScanNegativeSection();testScanPartial();testScanBackwardPartial();testScanAmpersandNoEscapeTag();testScanTripleStache();testScanSectionWithTripleStacheInside();testScanSetDelimiter();testScanResetDelimiter();testSetDelimiterWithWhitespace();testSingleCharDelimiter();testParseBasic();testParseVariables();testParseSection();testParseIndexes();testParseNegativeSection();testParseNestedSections();testMissingClosingTag();testBadNesting();testBasicOutput();testOneVariable();testMultipleVariables();testNumberValues();testObjectRender();testObjectToStringRender();testArrayRender();testEscaping();testMustacheInjection();testTripleStache();testAmpNoEscaping();testPartial();testNestedPartials();testNegativeSection();testSectionElision();testSectionObjectContext();testSectionArrayContext();testRenderWithWhitespace();testRenderWithWhitespaceAroundTripleStache();testRenderWithWhitespaceAroundAmpersand();testFalsyVariableNoRender();testRenderOutput();testDefaultRenderImpl();testSectionExtensions();testMisnestedSectionExtensions();testNestedSection();testShootOutString();testShootOutReplace();testShootOutArray();testShootOutObject();testShootOutPartial();testShootOutRecurse();testShootOutFilter();testShootOutComplex();testDottedNames();testImplicitIterator();testPartialsAndDelimiters();testStringPartials();testMissingPartials();testIndentedStandaloneComment();testNewLineBetweenDelimiterChanges();testMustacheJSApostrophe();testMustacheJSArrayOfImplicitPartials();testMustacheJSArrayOfPartials();testMustacheJSArrayOfStrings();testMustacheJSUndefinedString();testMustacheJSTripleStacheAltDelimiter();complete()}var Hogan=Hogan||require("../lib/hogan"),doc=this.document;if(!this.output)var output=function(e){return doc?appendText(doc.getElementById("console"),e):console.log(e)};var passed=0,failed=0;doc?window.onload=runTests:runTests();